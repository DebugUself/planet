<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>











<head>
<title>Planet DebugUself</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="Planet/2.0 +http://www.planetplanet.org">
<link rel="stylesheet" href="planet.css" type="text/css">
<link rel="alternate" href="http://planet.du.zoomquiet.us/atom.xml" title="" type="application/atom+xml">
</head>

<body>
<h1>Planet DebugUself</h1>

<div class="daygroup">
<h2>August 27, 2017</h2>

<div class="channelgroup">







<h3><a href="http://blog.junyu.io/" title="浚宇的博客">junyu</a></h3>


<div class="entrygroup" id="http://blog.junyu.io/posts/0707-python-env-config.html">
<h4><a href="http://blog.junyu.io/posts/0707-python-env-config.html">Python环境出坑记</a></h4>
<div class="entry">
<div class="content">
<blockquote class="blockquote-center">祸兮福所倚，福兮祸所伏</blockquote>

<a id="more"></a>
<p>理想很美好，现实很骨干…..</p>
<h2 id="坑坑坑"><a href="http://blog.junyu.io/atom.xml#坑坑坑" class="headerlink" title="坑坑坑"></a>坑坑坑</h2><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Goal : Office PC -&gt; Install Vmware &amp; CentOS -&gt; Pythoner</div><div class="line">But : Settings -&gt; how to root -&gt; how to install git -&gt; how to talk to unblock openssh</div><div class="line">               -&gt; how to use zsh -&gt; how to use oh-my-zsh</div><div class="line">               -&gt; how to use atom -&gt; libsecret error -&gt; still in keng</div><div class="line">               -&gt; how to install pyenv -&gt; how to make it work</div><div class="line">               -&gt; how to make shell work for me -&gt; how to config -&gt; where is shortcut?</div><div class="line">               -&gt; how to blog -&gt; how to use Chinese input</div><div class="line">               -&gt; how to know linux very well -&gt; linux books &amp; shell programming learning</div><div class="line">Crazy But:     -&gt; pyenv install do not work here -&gt; pool internet -&gt; need another way -&gt; mirror</div><div class="line">               -&gt; pip install do not work here too -&gt; pool internet -&gt; need another way -&gt; mirror again</div><div class="line"></div><div class="line">On My MAC -&gt; why there are so many pythons? -&gt; what is anaconda python -&gt; which python am i using</div><div class="line">          -&gt; how to clean them all -&gt; how to make them all works for me as I want?</div><div class="line"></div><div class="line">Jupyter Notebook -&gt; want to use an package -&gt; pyenv installed</div><div class="line">                 -&gt; conda doesn&amp;apost -&gt; cannot use</div></pre></td></tr></table>
<p>上面每一个箭头都是一段入坑出坑，也许还有没出来的坑。踩坑多了，也就不觉得自己在坑里。今天梳理一下Python 环境相关的问题和坑，作一个经验总结。</p>
<h2 id="前情提要"><a href="http://blog.junyu.io/atom.xml#前情提要" class="headerlink" title="前情提要"></a>前情提要</h2><p>你有一台MAC 或者Linux 系统，已经安装了zsh 和 Oh-my-zsh ，下一步准备和python 一起愉快的玩耍。你肉身在墙内，由于种种网络环境的限制还不一定能够完全自由的站在墙外。使用的环境主要以python3 为主，但是语言这件事情，总是越自由一些越好不是么？也就是说最好可以对python 的环境进行有效的管理。<br />在你还对python 懵懵懂懂的时候，有人推荐你安装了anaconda，据说这个神器可以一劳永逸的解决环境问题，让你专注在编程本身。你装了Anaconda，但依然没有摆脱折腾环境的命运，后来还折腾过Anaconda3 ，因为原来装的那个python 自带的是2。<br />又过了一段时间，不断的听说pyenv 、pyenv virtualenv 惊闻anaconda 也是一个大大大坑，自己还浑然不知。随着学习的深入，真是举步维艰，每一次都倒在折腾环境上</p>
<blockquote>
<p>系统里既有python2 又有python3，不知道如何切换，在pip 安装包时经常混淆。打开jupyter notebook 也是很容易就报错，一查发现还是环境的问题，还不容易搞明白了，安装一个包，结果发现总是连不上pypi，有一种想砸电脑的冲动……<br /><code>pyenv virtualenv -&gt; pyenv -&gt; anaconda python -&gt; zsh/bsh/csh -&gt; internet</code></p>
</blockquote>
<p>忍无可忍，无需再忍，把这个事情搞清楚吧～</p>
<h2 id="基本知识"><a href="http://blog.junyu.io/atom.xml#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="一个系统里可以安装N个python"><a href="http://blog.junyu.io/atom.xml#一个系统里可以安装N个python" class="headerlink" title="一个系统里可以安装N个python"></a>一个系统里可以安装N个python</h3><p>在一台Linux中可以安装多个版本的Python，但是系统默认的一般都只有一个，所以你需要一个可以管理多个版本python的软件来总体管理。如果你对Windows系统比较熟悉，可以类比一台Win下安装了一个虚拟机，在这个虚拟机里，你想怎么搞都行。这个python环境管理的工具就叫：pyenv。</p>
<h3 id="Linux-如何执行命令"><a href="http://blog.junyu.io/atom.xml#Linux-如何执行命令" class="headerlink" title="Linux 如何执行命令"></a>Linux 如何执行命令</h3><p>我们在终端输入的任何一条命令，Shell 都会去到几个和“环境变量”（$PATH）相关的文件中寻找对应的路径下是否有可以执行的文件。这些可执行的文件里放着的是我们输入的命令和如何执行这些命令的代码说明。只有找到了这个文件，Shell才知道如何执行命令。这个过程可以简化的理解为：<br /><code>输入命令 -&gt; shell 读入命令 -&gt; 查找文件 -&gt; 定位文件中的环境变量 -&gt; 浏览环境变量对应的路径下的文件 -&gt; 在文件里寻找命令和执行方法 -&gt; 找到了，按照要求执行 -&gt; 找不到，输出找不到</code></p>
<h3 id="如何执行python-的命令"><a href="http://blog.junyu.io/atom.xml#如何执行python-的命令" class="headerlink" title="如何执行python 的命令"></a>如何执行python 的命令</h3><p>有了上面的知识，理解起来就很简单了，python 输入终端后，系统首先会去找到解释这个python 命令的文件，然后执行。由于系统里有多个python，那么调用哪一个python，其实就是看环境变量中哪一个python 环境对应的目录靠前，问题迎刃而解。</p>
<h3 id="什么是Shell"><a href="http://blog.junyu.io/atom.xml#什么是Shell" class="headerlink" title="什么是Shell"></a>什么是Shell</h3><p>我们要和Linux 交流，要说Linux 能听懂的语言，并且要通过一个方式传递给Linux 系统。这个语言就是Shell 脚本语言，而这个工具，我们看到的是终端，其实终端里用于交互的也可以先成为Shell，可以理解为和Linux 交互的一种工具。Shell 把命令也就是Shell脚本传递给Linux，Linux知道我们的意图后执行返回输出，大概可以这么理解。</p>
<h3 id="多个不同的Shell-和环境变量"><a href="http://blog.junyu.io/atom.xml#多个不同的Shell-和环境变量" class="headerlink" title="多个不同的Shell 和环境变量"></a>多个不同的Shell 和环境变量</h3><p>除了python的哪些坑，其实shell本身也有一些坑，shell有很多种，Bash，Z-bash等等。我习惯用的是Z-bash，也就是zsh。在启用了zsh之后，原来的一些环境变量需要进行调整，因为最终zshrc会调用一部分其他环境变量，还有一些是在zshrc自己做的配置。环境变量的相关文件语法是shell脚本语言的语法。建议有时间精力可以了及相关知识，会少入很多坑。</p>
<h2 id="代码实践"><a href="http://blog.junyu.io/atom.xml#代码实践" class="headerlink" title="代码实践"></a>代码实践</h2><p>理论知识再多，不如来看看代码。</p>
<h3 id="shell常用的和环境变量相关的命令"><a href="http://blog.junyu.io/atom.xml#shell常用的和环境变量相关的命令" class="headerlink" title="shell常用的和环境变量相关的命令"></a>shell常用的和环境变量相关的命令</h3><ul>
<li><code>$ env</code>和<code>$ printenv</code>用于展示环境变量配置文件的内容。</li>
<li><code>$ set</code>展示所有的变量</li>
<li><code>$ export</code>将变量导出到接下来的程序环境中</li>
<li><code>$ echo</code>输出，如果跟着变量名，会把变量的值输出</li>
</ul>
<h3 id="相关的环境变量配置文件"><a href="http://blog.junyu.io/atom.xml#相关的环境变量配置文件" class="headerlink" title="相关的环境变量配置文件"></a>相关的环境变量配置文件</h3><p>涉及到的文件<br /><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/etc/profile</div><div class="line">/etc/bashrc</div><div class="line">/etc/zshrc</div></pre></td></tr></table></p>
<p>如果是/etc/目录下则是所有用户共享的配置文件<br /><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">~/.profile</div><div class="line">~/.bash_profile</div><div class="line">~/.bashrc</div><div class="line">~/.zshrc</div></pre></td></tr></table></p>
<p>在自己的目录下则是仅有你这一个用户可用。</p>
<h3 id="环境变量示例"><a href="http://blog.junyu.io/atom.xml#环境变量示例" class="headerlink" title="环境变量示例"></a>环境变量示例</h3><ul>
<li><code>export PATH=&quot;/home/leon/.pyenv/bin:/usr/local/bin&quot;</code><br /><code>export</code>表示将变量导出到接下来的程序环境中。冒号是连接符号，这里程序会顺序的逐个去找对应的执行文件。bin文件夹下一般存放的是可执行的二进制文件，当我们输入命令的时候，程序就会逐个文件去找，如果找到了就会执行，找不到，会反馈找不到</li>
<li><p><code>eval &quot;$(pyenv init -)&quot;</code>这句命令稍微复杂，是理解pyenv和环境变量关系的关键，分为两部分，一部分是shell的命令，一部分是理解pyenv init命令。</p>
<ul>
<li>eval：脚本语言中表示将后面的内容按照命令的方式直接执行</li>
<li>$()的语法表示将命令执行的结果输出后再执行外面的命令，也就是说这一行会先执行 pyenv init - 之后，eval再执行 pyenv init - 的结果。</li>
<li>关于pyenv init的命令，参考这两个文件，说的非常清楚：</li>
<li><a href="https://github.com/pyenv/pyenv/blob/master/COMMANDS.md" target="_blank" rel="external">Command Reference</a></li>
<li><a href="https://github.com/pyenv/pyenv" target="_blank" rel="external">Simple Python Version Management: pyenv</a></li>
<li>整体解释：首先执行<code>pyenv init -</code>的命令后的输出替换双引号中的内容，然后将双引号中给定的文本作为shell 命令执行。命令说明可以参考<a href="http://www.unix.com/man-page/posix/1posix/eval/" target="_blank" rel="external">eval usage explan</a></li>
</ul>
</li>
<li><p>常用变量：<code>$HOME</code> 和 <code>$PATH</code></p>
</li>
</ul>
<h3 id="最佳实践"><a href="http://blog.junyu.io/atom.xml#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li>在自己的程序里跑:which python会发现调用的目录后，再执行 echo $PATH ,可以应证前面的目录或者其父目录一定在$PATH中。</li>
<li>查看自己的~/.zshrc 文件</li>
<li>了解anaconda python的路径，争取彻底处理,或者不会对自己现在的环境配置产生不良影响。</li>
</ul>
<h2 id="解决办法"><a href="http://blog.junyu.io/atom.xml#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>回到最初的问题，如何处理环境问题呢，整体思路是：如果你不了解如何采用命令行进行 anconda 或者conda 的配置方法时，建议全面放弃该整体环境。通过设置pyenv 插件的方式获得一个自己可控的多python 环境。这整个过程里都会涉及到对环境变量文件的修改，建议真正理解前面的知识点后再执行相关的操作。</p>
<h3 id="Bye-Anaconda"><a href="http://blog.junyu.io/atom.xml#Bye-Anaconda" class="headerlink" title="Bye Anaconda"></a>Bye Anaconda</h3><ul>
<li><a href="https://docs.continuum.io/anaconda/user-guide/tasks/integration/python-path" target="_blank" rel="external">找到可执行文件</a></li>
<li>按照[官方文档](<a href="https://docs.continuum.io/anaconda/install/uninstall" target="_blank" rel="external">https://docs.continuum.io/anaconda/install/uninstall</a> ）进行卸载。需要注意如果是zsh shell的使用者，最后删除环境变量要把bash 和zsh 都删除干净，以免后患。</li>
</ul>
<h3 id="配置需要的环境"><a href="http://blog.junyu.io/atom.xml#配置需要的环境" class="headerlink" title="配置需要的环境"></a>配置需要的环境</h3><ul>
<li>pyenv：参考官方文档<a href="https://github.com/pyenv/pyenv" target="_blank" rel="external">pyenv</a>，注意环境变量的配置和启动后的环境检查。</li>
<li>ipython 安装：按照官方<a href="https://ipython.org/install.html" target="_blank" rel="external">文档</a>安装，令人发指的简单。</li>
<li>jupyter notebook 安装：按照官方<a href="http://jupyter.org/install.html" target="_blank" rel="external">文档</a>的介绍，同样是令人发指的简单。</li>
</ul>
<p>注意，以上环境安装之前，先确认处于的python 环境是你需要的python 环境。</p>
<h2 id="回到Anaconda"><a href="http://blog.junyu.io/atom.xml#回到Anaconda" class="headerlink" title="回到Anaconda"></a>回到Anaconda</h2><p>之前我也推荐给小伙伴安装anaconda套件，这样就可以不管各种环境问题了，这是一个初级的处理方案，当你开始对python 有更多了解有更多定制话的需求之后,当初盲目安装的anaconda反而成了“不可承受之重”，因为自己压根不知到anaconda默默的做了哪些系统配置的改动。<br />其实错并不在anaconda 本身，如果你是数据科学工作者，并不希望被环境折腾，利用这样的套件是避免底层环境配置的好办法。但是对于python 的开发者来说，了解python 的生态系统，能够自己动手配置适合自己开发的环境还是很有必要的。更了解底层的机制有利于我们更好的了解计算机本身。这时候的ipython 和jupyter 也更容易被我们所用。</p>
<h2 id="未解之谜"><a href="http://blog.junyu.io/atom.xml#未解之谜" class="headerlink" title="未解之谜"></a>未解之谜</h2><p>最后其实留了一个小问题：pip 的安装。一个很坑的事情是python的很多一手资源获取的速度非常非常的慢。解决办法有两个，翻出去，或者找一个国内的镜像。<br />动手试试看吧～如果有必要，以后再来增补这一部分的内容。</p>
<h2 id="私货"><a href="http://blog.junyu.io/atom.xml#私货" class="headerlink" title="私货"></a>私货</h2><p>优先和程序沟通，出了啥问题都先找谷哥是新手的第一阶段，其实程序一般都会提供足够的信息，当自己知道的不够多的时候再找谷哥。怎么和程序沟通，自然是找帮助文档，怎么找帮助文档，shell中主要有两个命令可以参考:<br /><code>XXX -h</code><br /><code>man XXX</code><br />一般来说都会有自己想要的答案。</p>
<p>其他的命令或者编程中需要查看的，自己应该优先探索，了解清楚一个如何方便调取这些内容的方法和体系，事半功倍。</p>
<h2 id="Reference"><a href="http://blog.junyu.io/atom.xml#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://github.com/pyenv/pyenv-virtualenv" target="_blank" rel="external">pyenv-virtualenv</a></li>
<li><a href="https://github.com/pyenv/pyenv" target="_blank" rel="external">pyenv</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-a-linux-vps" target="_blank" rel="external">Linux enviromental variables intro</a></li>
<li><a href="https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe" target="_blank" rel="external">diffence between pyenv and pyenv-virtualenv</a></li>
<li><a href="https://help.ubuntu.com/community/EnvironmentVariables" target="_blank" rel="external">Ubuntu Official Environment Variables Intro</a></li>
<li><a href="https://book.douban.com/subject/3519360/" target="_blank" rel="external">Shell 脚本学习指南</a></li>
<li><a href="https://stackoverflow.com/questions/7411455/what-does-export-do-in-shell-programming" target="_blank" rel="external">What does “export” do in shell programming?</a></li>
<li><a href="http://www.gnu.org/software/bash/manual/bash" target="_blank" rel="external">Bash Reference Manual</a></li>
<li><a href="https://en.wikipedia.org/wiki/Command_substitution" target="_blank" rel="external">$()的语法解释</a></li>
<li><a href="https://stackoverflow.com/questions/30034840/what-are-the-differences-between-conda-and-anaconda" target="_blank" rel="external">what are the differences between conda and anaconda</a></li>
<li><a href="https://stackoverflow.com/questions/20994716/what-is-the-difference-between-pip-and-conda" target="_blank" rel="external">what is the difference between pip and conda </a></li>
<li><a href="https://conda.io/docs/user-guide/tasks/manage-environments.html" target="_blank" rel="external">Conda manage environments</a></li>
<li><a href="https://conda.io/docs/user-guide/getting-started.html" target="_blank" rel="external">Conda getting-started</a></li>
</ul>
<blockquote class="blockquote-center"><a href="http://blog.junyu.pro" target="_blank" rel="external">完</a></blockquote>


<h2 id="ChangeLog"><a href="http://blog.junyu.io/atom.xml#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h2><p>170827 新建</p></div>







<p class="date">
<a href="http://blog.junyu.io/posts/0707-python-env-config.html">August 27, 2017 02:15 PM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>August 26, 2017</h2>

<div class="channelgroup">







<h3><a href="http://blog.zoomquiet.io/" title="">zoom.quiet</a></h3>


<div class="entrygroup" id="tag:blog.zoomquiet.io,2017-08-27:/dsl-atop-openresty.html">
<h4><a href="http://blog.zoomquiet.io/dsl-atop-openresty.html">用 DSL 们构筑商用系统</a></h4>
<div class="entry">
<div class="content">
<h1 id="building-business-systems-with-dsls-for-nginx-openresty">Building Business Systems with DSLs for <span class="caps">NGINX</span> <span class="amp">&amp;</span> OpenResty<a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#building-business-systems-with-dsls-for-nginx-openresty" title="Permanent link">¶</a></h1>
<p>~ 来自春哥的分享</p>
<h2 id="_1">背景<a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#_1" title="Permanent link">¶</a></h2>
<ul>
<li>5年前也听录了一次 春哥的分享:<a href="http://blog-zq-org.qiniucdn.com/pyblosxom/oss/openresty-intro-2012-03-06-01-13.html">由Lua 粘合的Nginx生态环境</a></li>
<li>然后, 神奇的引发了各种后来的然后</li>
<li>去年, 在 <span class="caps">NGINX</span> 大会上, 春哥才真正讲出了10年前设计 OpenResty 前身时内心的宏大构想</li>
<li>所以, 值得认真 review 一下:<ul>
<li>视频:<a href="https://www.youtube.com/watch?v=w2RAZLptE-U">Building Business Systems with Domain-Specific Languages for <span class="caps">NGINX</span> <span class="amp">&amp;</span> OpenResty | Cloudflare - YouTube</a></li>
<li>文稿:<ul>
<li><a href="https://www.nginx.com/blog/building-business-systems-with-domain-specific-languages-for-nginx-openresty-part-1/">Domain-Specific Languages for <span class="caps">NGINX</span> <span class="amp">&amp;</span> OpenResty, Part 1</a></li>
<li><a href="https://www.nginx.com/blog/building-business-systems-with-domain-specific-languages-for-nginx-openresty-part-2/">Domain-Specific Languages for <span class="caps">NGINX</span> <span class="amp">&amp;</span> OpenResty, Part 1</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="tldr"><span class="caps">TL</span>;<span class="caps">DR</span><a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#tldr" title="Permanent link">¶</a></h2>
<p><img alt="p0" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide0_First-image.png" /></p>
<p>nginx.conf 2016 春哥进行的是压轴分享,对于在主厅面对千人的演讲, 他表示了虚伪的不好意思.</p>
<p><img alt="p2" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide2_OpenResty.png" /></p>
<p>OpenResty 项目发起自10年前,现在已经有完备的团队专门进行维护和开发,
twitter 官方帐号是: @OpenResty</p>
<p>推荐关注</p>
<p><img alt="p4" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide4_Lua-Libraries.png" /></p>
<p>OpenResty 在 <span class="caps">NGINX</span> 内嵌了 LuaJIT 环境,
得以支持丰富的 Lua 库,结合 <span class="caps">NGINX</span> 原生的非阻塞机制,
支持我们可以快速的完成复杂的 web 应用系统,
当前 <code>lus-resty-*</code> 库已经支持非常多领域功能,比如说:</p>
<ul>
<li>各种数据库客户端: MySQL/Pg/MongoDB/RabbitMQ/..</li>
<li>各种 upstreams 的健康检验</li>
</ul>
<p>是的, OpenResty 是成长非常迅猛的社区</p>
<p><img alt="p5" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide5_NGINX-LuaJIT.png" /></p>
<p>OpenResty 不仅仅将 LuaJIT 嵌入到 <span class="caps">NGINX</span> ,
感谢 Lus 的 <code>co-routines</code> 特性, 我们还创造了独有的特性,比如说:</p>
<ul>
<li>light threads</li>
<li>timers</li>
</ul>
<h3 id="or"><span class="caps">OR</span> 的世界观<a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#or" title="Permanent link">¶</a></h3>
<p><img alt="p6" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide6_The-All-Inclusive-Philosophy.png" /></p>
<p>OpenResty 的世界观是 <code>全包容</code> 的,
不排斥其它任何技术, 事实上 resty 用户来自从 <span class="caps">JAVA</span> 到 Go 各种技术人群.</p>
<p><span class="caps">NGINX</span> 可以在后端到客户端之间作很多有趣的事儿,
所以, 在 OpenResty 帮助下, 可以很好的完成混合解决, 能和旧系统无缝衔接.</p>
<p><img alt="p7" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide7_Simple-Small-Fast-Flexible.png" /></p>
<p>OpenResty 的目标是:</p>
<ul>
<li>简洁</li>
<li>轻便</li>
<li>快速</li>
<li>灵活</li>
</ul>
<p>认真研究 Lua 后, 我们发现这真是个神奇的恩物, 不仅小而且快,更加灵活,支撑复杂的大型系统也没有问题.</p>
<p>总之这是个设计务实,发展良好,基础稳定的好语言,
OpenResty 将 Lua 和 <span class="caps">NGINX</span> 深度结合, 倍增了双方的实力.</p>
<p><img alt="p8" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide8_Synchronously-Nonblocking.png" /></p>
<p>OpenResty 的 I/O 模式是 <code>无阻塞异步</code>,
虽然 异步 在现实世界中无处不在,
但是,人类的头脑只习惯同步, 当然,俺也反感回调</p>
<p><img alt="p9" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide9_Light-Threads-Semaphores.png" /></p>
<p>所以,我们设计了 纤程和信号 来模拟并发, 而实际上只有一个唯一的系统线程.</p>
<p><img alt="p10" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide10_Cosockets.png" /></p>
<p>并发明了: ‘Cosockets’ ~ 肯接字 (哈N 年前就想翻译了, 现在才有好想法儿)</p>
<p>类似 <span class="caps">BSD</span>/Lua 套接字的容器,
支持我们象写 <span class="caps">PHP</span> 代码一样写同步表述, 但实际运行是完全异步的.</p>
<p>(<code>是也乎:</code></p>
<p>golang 其实也借鉴了我们这一设计 )</p>
<p><img alt="p11" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide11_Timers-and-Sleeping.png" /></p>
<p>我们也重新定义了 计时器和睡眠原语,
将异步和下游任务在 <span class="caps">NGINX</span> 中完备的分离了,
使用起来就象 cron .</p>
<p><img alt="p12" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide12_Shm-Based-Dictionaries-and-Queues.png" /></p>
<p>同时还发明了 <code>shm</code> ~ 内存分享式字典和队列,
以便支持我们的应用在 <span class="caps">NGINX</span> 不同进程间分享数据,
同时又不打破 <span class="caps">NGINX</span> 的异步性能.</p>
<p><img alt="p13" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide13_Dynamic-SSL-Handshakes.png" /></p>
<p>而且刚刚我们也开始支持 动态<span class="caps">SSL</span>握手, 以便支持下游的 <span class="caps">HTTPS</span> 事务.</p>
<p><img alt="p14" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide14_Dynamic-SSL-Handshakes-Example.png" /></p>
<p>比如在 Cloudflare, 作为<span class="caps">CDN</span> 供应商, 有很多客户以及虚拟服务器和边缘服务器构成网络,</p>
<p>要面对的一个主要问题就是: <span class="caps">SSL</span> 证书/密钥太多</p>
<p>理论上应该根据实际请求来动态加载对应的证书/密钥,
这样我们就可以同时持有无限量的 <span class="caps">SSL</span> 证书/密钥,
感谢本地流量调度, 虽然不可能有单机可以查询所有用户的流量.</p>
<p>进一步的, 在 OpenResty 可以通过 共享内存和工作级缓存中管理 <span class="caps">SSL</span> 证书/密钥,</p>
<p>数据 — 比如: 证书/密钥 — 当前已支持在 <a href="https://github.com/alticelabs/kyoto">Kyoto Tycoon</a> 中分发,
其它后端,比如说 Redis 或其它分布式存储也当然可以了.</p>
<p><img alt="p15" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide15_Dynamic-Load-Balancers.png" /></p>
<p>通过 <span class="caps">NGINX</span> 中的 Lua 进行动态加载平衡也是能的.</p>
<p><img alt="p16" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide16_Dynamic-Load-Balancers-Ex.png" /></p>
<p>比如这一则配置:</p>
<ul>
<li>几行就可以定义一系列复杂的决策</li>
<li>动态, 意味着你可以在该级别上对每个请求灵活应用不同的均衡策略</li>
<li>并指定重试策略:<ul>
<li>比如, 特定请求没有获得响应时</li>
<li>可以选择忽略</li>
<li>也可以选择请求和请求的位置</li>
<li>等等,都在 <code>balancer_by_lua_block</code> 中可以声明</li>
</ul>
</li>
<li>同时不影响 <span class="caps">NGINX</span> 各种标准模块,比如说:<ul>
<li><a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">Proxy</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html">FastCGI</a></li>
<li><a href="http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html">uwsgi</a></li>
<li>… 等等的使用</li>
</ul>
</li>
<li>以及 <span class="caps">NGINX</span> 核心模块,比如: keepalive,连接池等等, 也一样开箱即用</li>
</ul>
<p><img alt="p17" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide17_ngx_stream_lua_module-TCP-UDP.png" /></p>
<p>最近我们创建了 <a href="https://github.com/openresty/stream-lua-nginx-module">ngx_stream_lua_module</a> 模块来替代以往的
<a href="https://github.com/openresty/lua-nginx-module">ngx_ HTTP_lua_ module</a></p>
<p>通过 <span class="caps">NGINX</span> 核心子系统,来支持实现通用的 <span class="caps">TCP</span>/<span class="caps">UDP</span> 服务,</p>
<p>实际上 <a href="http://openresty.org/en/">OpenResty® - Official Site</a> 
本身的 <span class="caps">DNS</span> 服务器就由此模块支撑,
还有人拿个模块实现了类似 syslog 的 <span class="caps">TCP</span> 守护进程, 来接收远程的大量日志.</p>
<p><img alt="p18" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide18_Advanced-Debugging-Profiling-Tools-Based-on-GDB-SystemTap.png" /></p>
<p>多年以来, 我们积累了大量的专用测试工具.</p>
<p>在 Cloudflare, 运营有全球范围的复杂大型网络,
很多问题发生的几率仅仅有 1% 或 0.1% 甚至于 0.001%,
几乎难以复现, 必须依赖高级调试工具来完成.</p>
<p>已经开源了很多基于 <span class="caps">GDB</span> 以及 SystemTap 的工具:</p>
<ul>
<li><span class="caps">GDB</span> 主要调试死锁进程,借助 <span class="caps">GDB</span> 以及 dump 工具, Mike Pall 已经修复了10多个隐藏在 <span class="caps">JIT</span> 中非常深的积年老问题</li>
<li>SystemTap 则是非常赞的 RedHat 工程师贡献的动态追踪平台,<ul>
<li>允许分享分析运行时系统, </li>
<li>从 内核到 <span class="caps">NGINX</span> 整个儿软件桟以及用户的 Lua 业务脚本, </li>
<li>都能在对生产系统微小影响下快速分析出来,</li>
<li>甚至于不用关闭防火墙</li>
<li>可以直接进行线上活体分析</li>
<li>&lt;— 这才是未来系统开发的应该姿势</li>
</ul>
</li>
</ul>
<p>(<code>是也乎:</code></p>
<p>嗯哼? <span class="caps">LISP</span> 构造的系统, 从一开始就这样的哪?! )</p>
<h3 id="or_1"><span class="caps">OR</span> 的应用场景<a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#or_1" title="Permanent link">¶</a></h3>
<p><img alt="p19" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide19_C2000K.png" /></p>
<p>随着近几个月, 我们发布的重要功能,
OpenResty 已在真实客户单主机上支持住了 200万 级别的并发请求,</p>
<p>已经有客户在生产环境中部署了这种级别的推送系统.</p>
<p><img alt="p20" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide20_Web-API-and-Microservices.png" /></p>
<p>另外一个常见领域是接口和微服务,</p>
<p>很多人使用 OpenResty 构建这类服务,比如:
<a href="https://github.com/Mashape/kong">Mashape’s Kong</a>平台,
以及 <a href="https://github.com/adobe-apiplatform/apigateway">Adobe’s <span class="caps">API</span> Gateway</a></p>
<p>此外, 一些美国银行使用 OpenResty 来管理路由器流量,</p>
<p>同时, 一些更大的中国互联网公司, 在用 OpenResty 构建实时股票信息服务, 这些接口是其中流量最大的,</p>
<p>还有用来发布实时天气信息接口的…</p>
<p>等等吧, OpenResty 的应用可能是无限的.</p>
<p><img alt="p21" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide21_Web-Gateways.png" /></p>
<p>另外一个 OpenResty 的应用场景是 web 网关,
很多 <span class="caps">CDN</span> 厂商都在这样使用.</p>
<p>我们还知道有人用 OpenResty 来管理通用 <span class="caps">TCP</span>/<span class="caps">UDP</span> 流量,</p>
<p>Lua 可以支持你的网关在运行中得以变化,
基于互联网的动态性, 
<span class="caps">CDN</span> 厂商必须灵活的应对客户的不同需求, 而客户的需求越来越复杂化.</p>
<p>甚至于人们在期待可以包含业务逻辑,比如常见的想动态修订配置文件,来支持软件更新, 等等出于实际需求的要求.</p>
<p>选择 Lua 令一切变的可能,
因为 <span class="caps">JIT</span> (即时编译)的机制,
可以随时根据变更的配置生成新的规则, 并根据不同的请求进行对应的流量优化…</p>
<p><span class="caps">NGINX</span> 原先就支持基于 <span class="caps">HUP</span>信号 的配置重加载, 
但是, 这对于厂商而言成本太高, 因为无法精确的退出相应请求来重启.</p>
<p>另外, 缓存也是个大问题:</p>
<ul>
<li>有时一个客户的缓存非常冷</li>
<li>但是,又不能为了释放这部分数据而重启整个儿缓存</li>
<li>这对其它用户来说太惨了…</li>
</ul>
<p><img alt="p22" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide22_Web-Applications.png" /></p>
<p>OpenResty 原先设计目标是支持完备的web 应用,
第一个案例是网站, 所以,有了 <a href="http://openrety.org">openrety.org</a></p>
<p>如今有越来越多的传统网站,在用 OpenResty 从头开始构建</p>
<p><img alt="p23" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide23_Web-Applications-Products-Details-Page.png" /></p>
<p>例如 京东网, 中国最大的 <span class="caps">B2C</span> 电子商务服务平台之一.
在各种营销日, 他们必须面对海量的请求,
类似美国的黑色星期五, 在中国则是 11.11</p>
<p>(<code>是也乎:</code>
问题在中国的光棍节营销流量, 是黑色日期五的几个数量级哪!!!
毕竟, 美国的打折多数是线下的… )</p>
<p>最早他们使用 Starnet 技术, 经常崩溃,
后来迁移到 <span class="caps">JAVA</span> 技术桟, 全然崩溃.</p>
<p>最终迁移到 OpenResty ,虽然后端依然是 <span class="caps">JAVA</span>,
但是迎接所有流量的全部是 OpenResty 了, 从此再也没有崩溃过.</p>
<p>现在他们使用 OpenResty 来生成复杂的网页.</p>
<p>比如这个截屏,是 iPhone 的详细产品信息页,
类似页面吸引了主要的流量, 基于 OpenResty 的模板库来生成动态页面, 这是个非常长的页面,只截取了顶部,</p>
<p>他们内部维护了一个非常庞大的模板库,
并用 Redis 来缓存数据 ,以免流量直接击中后端的 <span class="caps">JAVA</span> 服务,</p>
<p>春哥曾经询问 <span class="caps">JD</span>, 是否需要优化, 他们回答,速度已经足够快, 不用了,谢谢…</p>
<p>(<code>是也乎:</code></p>
<p>这可能是由于性能太好而丢失定制服务的最好案例,
MySQL 只能表示 23333 了… )</p>
<p><img alt="p24" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide24_OpenResty-Website.png" /></p>
<p>我们自己则重构了官方网站,
整个网站使用 Lua 在 OpenResty 上重写而成,</p>
<p>使用 PorstgreSQL 作为后端数据存储,
通过 OpenResty 直接和数据库交互,</p>
<p>通过 <span class="caps">NGINX</span> 的异步非阻塞进程来处理 <span class="caps">IO</span>, 非常快速并便宜,</p>
<p>基于 Pg 内置的全文搜索而支持了网站的内部搜索功能.</p>
<p><img alt="p25" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide25_Distributed-Storage-Systems.png" /></p>
<p>这是令春哥自己都惊讶的领域:</p>
<ul>
<li>作为中国最大的网站之一 sina.com</li>
<li>发布有类似 Jawbox 的网络存储产品</li>
<li>他们不仅用 OpenResty 来构建前端</li>
<li>而且还用在后台直接处理文件 I/O</li>
<li>对于这种操作他们非常自得</li>
<li>也非常自豪的成为 OpenReaty 核心组件贡献方之一</li>
</ul>
<p><img alt="p26" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide26_Datanet.png" /></p>
<p>Datanet 则是另外一个类似的项目,
虽然没开源, 但是,作者在努力中,</p>
<p>创始人是 Russell Sullivan,
在 twitter 是 @jaksprats</p>
<p>正在基于 OpenResty 构建一个分布式数据网络, 推荐大家去直接嗯哼…</p>
<p><img alt="p27" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide27_Conflict-Free-Replicated-Data-Types.png" /></p>
<p><code>CRDT</code> ~ 无冲突数据复制类型,
简单的说, 这是全新的复杂理论,
涉及复杂的算法和论文, 还在折腾中…</p>
<p><img alt="p28" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide28_Forming-a-Stateful-Network.png" /></p>
<p>基本上象个 <code>半p2p</code> 网络,
每个节点都可以有状态,通过 类似 p2p 的机制完成自动同步,</p>
<p>为什么叫 <code>半p2p</code> 网络,因为这其中必须有某种中心,
可以是大型数据中心, 
以便支持暂时下线的节点, 重新上线时,快速发现差异完成同步….</p>
<p>是的, 机制很复杂要说明白得额外2小时…</p>
<p>(<code>是也乎:</code></p>
<p>不就是不完备的区块链网络嘛… )</p>
<h3 id="sregex">大事儿: sregex<a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#sregex" title="Permanent link">¶</a></h3>
<p><img alt="p29" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide29_Sregex.png" /></p>
<p>sregex &lt;— 春哥一直在造的轮那 ~ 正则表达式引擎,</p>
<p>当然是为了真实的业务需求</p>
<p>(<code>是也乎:</code></p>
<p>但是,这是阻止不了从头造轮子的快感的…嗯哼! )</p>
<p><img alt="p30" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide30_web-server.png" /></p>
<p>本质上她必须可以支撑处理流式数据,
毕竟 web 服务器要处理的数据理论上是无限大的.</p>
<p><img alt="p31" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide31_4KB-buffer.png" /></p>
<p>关键问题是高速处理缓冲区块:</p>
<ul>
<li>缓冲总是混沌的</li>
<li>通常很小,比如 4k</li>
<li>数据一进入, 就必须完成处理,得到我们需要的,并作出决定:<ul>
<li>丢弃</li>
<li>或是通过</li>
</ul>
</li>
<li>而且是单向流水线<ul>
<li>一但数据块被处理</li>
<li>立即将被下一组填充</li>
</ul>
</li>
<li>这一构想很得趣, 但是,不简单</li>
<li>算法非常困难, 传统的都不行…</li>
</ul>
<p><img alt="p32" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide32_4KB-buffer-2.png" /></p>
<p>回溯算法在主流正则表达式引擎中很流行,</p>
<p>基本上, 当你找不到匹配时,就将指针逈后移动再重试.</p>
<p><span class="caps">PCRE</span> 以及其它很多引擎都是基于这一算法的, 但是,包含了很多问题,不仅仅是固定缓冲区的要求.</p>
<p>还可能引发非常昂贵的系统资源浪费, 
这种现象我们定义为: <code>病理行为</code></p>
<p><img alt="p33" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide33_Xregex%E2%80%99s-BFA-Engine-Performance-Benchmark.png" /></p>
<p>春哥构建了 <a href="https://en.wikipedia.org/wiki/Deterministic_finite_automaton"><span class="caps">DFA</span></a>
(确定性有限自动机),
当前性能尚可, 如图中所示:</p>
<ul>
<li>橙色-&gt;Google <span class="caps">RE2</span></li>
<li>紫色-&gt;<span class="caps">PCRE</span> <span class="caps">JIT</span></li>
<li>黑色-&gt;<span class="caps">PCRE</span></li>
<li>绿色-&gt;<span class="caps">PCRE2</span>解释器</li>
<li>蓝色-&gt;<span class="caps">PCRE2</span> <span class="caps">JIT</span></li>
<li>黄色-&gt;sregex <span class="caps">DFA</span> 原型</li>
</ul>
<p><span class="caps">PCRE</span> 是 C 实现的 Perl 兼容正则表达库,性能口碑很好</p>
<p><img alt="p34" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide34_benchmark2.png" /></p>
<p>在这个有点儿复杂的测试案例中:</p>
<ul>
<li><span class="caps">RE2</span> 比 <span class="caps">PCRE</span> 好</li>
<li>甚至于比解释器版本还好</li>
<li>但是,  sregex <span class="caps">DFA</span> 原型 依然更好点儿</li>
</ul>
<p><img alt="p35" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide35_benchmark3.png" /></p>
<p>而在 <code>/d.*?d/</code> 这一简单案例测试中:</p>
<ul>
<li>我们的原型获得了极大的优势</li>
<li>因为 <span class="caps">DFA</span> 可以进行智能优化</li>
</ul>
<p><img alt="p36" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide36_benchmark4.png" /></p>
<p>在 <span class="caps">PCRE</span> 提供的性能测试案例集中, 我们(黄色)领先一些</p>
<p><img alt="p37" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide37_benchmark5.png" /></p>
<p>这一正则表达式案例是从 ModSecurity 的核心规则中抽取的,
应用在 <span class="caps">WAF</span>(web 应用防火墙)过滤核心中.</p>
<ul>
<li>回溯引擎浪费了大量 <span class="caps">CPU</span> 资源,因为在反复回溯</li>
<li>sregex <span class="caps">DFA</span> 原型则相反, 非常快</li>
</ul>
<p>sregex 将是 OpenResty 接下来的重心!</p>
<ul>
<li>当前还不是产品状态, 只是个快速原型</li>
<li>春哥用大约2000行 perl 代码实现了一个正则表达式引擎</li>
<li>以便生成能被 clang/<span class="caps">GCC</span> 编译的 C 代码</li>
<li>完成这些,只是为了印证设想</li>
</ul>
<p>我们认为:</p>
<div class="highlight"><pre><span class="err">自己的</span> <span class="n">JIT</span> <span class="err">引擎比</span> <span class="n">Clang</span><span class="o">/</span><span class="n">GCC</span> <span class="err">更好</span><span class="p">,</span><span class="err">因为优化器更通用</span>
<span class="err">自己的</span> <span class="n">JIT</span> <span class="err">引擎比</span> <span class="n">Clang</span><span class="o">/</span><span class="n">GCC</span> <span class="err">更好</span><span class="p">,</span><span class="err">因为优化器更通用</span>
<span class="err">自己的</span> <span class="n">JIT</span> <span class="err">引擎比</span> <span class="n">Clang</span><span class="o">/</span><span class="n">GCC</span> <span class="err">更好</span><span class="p">,</span><span class="err">因为优化器更通用</span>
</pre></div>
<p>(<code>好吧, 重要的事儿得说三次</code>)</p>
<h3 id="dsl-lzsql"><span class="caps">DSL</span>实验: <span class="caps">LZSQL</span><a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#dsl-lzsql" title="Permanent link">¶</a></h3>
<p><img alt="p38" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide38_A-Web-Platform-As-A-Virtual-Machine.png" /></p>
<p>回到主题: 建立在 OpenResty 上的 <span class="caps">DSL</span></p>
<p>先分享了一系列 OpenResty 的新功能,</p>
<p>但是,更重要的是, 春哥认为:</p>
<ul>
<li>OpenResty 可以视作 <span class="caps">VM</span>(虚拟机)</li>
<li>就象 <span class="caps">JVM</span></li>
<li>可以更加强大, 更加面向 web</li>
</ul>
<p><img alt="p39" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide39_lz.taobao.com_.png" /></p>
<p>这个实验其实是7~8年前完成的,不算新鲜,但是,实验是值得回味的.</p>
<p>那时春哥供职 taobao, 是 alibaba 集团子公司, 是中国最大的 <span class="caps">B2C</span> 平台,
当时在数据分析部门,
客户是 taobao 的商家, 类似 eBay 的商家就是卖家一样.</p>
<p>客户需要一个流量分析工具, 
来统计店面的流量,和广告部署/销售间的影响力关系, 这是个非常大的产品.</p>
<p>(<code>是也乎:</code></p>
<p>为什么大? 因为要分析的数据量,相当于好几个 twitter 的数据量…. )</p>
<p><img alt="p40" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide40_Taobao-homepage.png" /></p>
<p>这是产品首页</p>
<p><img alt="p41" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide41_chart.png" /></p>
<p>给出了类似 google 分析样漂亮的图表, 所不同的是有更多数据报告.</p>
<p><img alt="p42" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide42_data-volume.png" /></p>
<p>由于 yaobao 的体量,数据量很大, 非常的大</p>
<p><img alt="p43" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide43_experiment-on-the-client-side.png" /></p>
<p>当时春哥 放胆在客户端进行各种尝试,8年前:</p>
<ul>
<li>整个儿应用逻辑已经全部在前端了</li>
<li>类似 gmail ,完全由一组运行在网页中的脚本构建</li>
<li>还引入了客户端模板:<ul>
<li>构建了一个能从模板生成 <span class="caps">JS</span> 代码的引擎</li>
</ul>
</li>
<li>另外也提供了 web 服务来驱动客户端应用</li>
<li>总之, web 服务是关键,是唯一运行在服务器上的东西<ul>
<li>将 <span class="caps">JSON</span> 发送给客户端</li>
<li><span class="caps">JS</span> 用编译后的模板生成页面区域</li>
</ul>
</li>
</ul>
<p><img alt="p44" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide44_server-side-.png" /></p>
<p>量子统计整体架构如上:</p>
<ul>
<li>OpenResty 位于后端和浏览器之间</li>
<li>后端是 MySQL 集群,因为数据量大, 光卷就有超过1亿个</li>
<li>另外还有实时统计集群作支撑</li>
<li>同时还作为一个开放平台发布 <span class="caps">JSON</span> 的 <span class="caps">API</span></li>
<li>以及 Memcached 和 Tokyo Tyrant 集群来管理其它元数据</li>
<li>但是, 相比其它系统要简洁的多,只用 <span class="caps">PHP</span> 来运行</li>
</ul>
<p><img alt="p45" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide45_-Inventing-LZSQL.png" /></p>
<p>春哥很快意识到关键问题:</p>
<ul>
<li>没有足够的人力来支撑开发</li>
<li>整个儿团队只有两个实习生</li>
<li>但是, 不得不将原先 <span class="caps">PHP</span> 编写的整个儿数据分析产品迁移到 OpenResty 平台</li>
<li>即使迫使实习生拼命写 Lua 代码,但是,面对复杂到狂乱的业务逻辑,这是个不可能的任务</li>
</ul>
<p>春哥用了一个晚上思考, 决定:</p>
<ul>
<li>基于对数据分析核心模型/模式的理解</li>
<li>构建自己的 <span class="caps">DSL</span></li>
<li>以便用更加自然的形式来描述业务</li>
</ul>
<p>毕竟: <code>什么是编程?</code></p>
<ul>
<li>本质上是和机器对话</li>
<li>令机器理解我们的意图</li>
<li>从而快速/便宜/可靠的完成业务</li>
</ul>
<p>所以, 编程的关键是:</p>
<div class="highlight"><pre><span class="err">提高同机器对话的效率</span>
</pre></div>
<p>那么, 如果你能用两个词或是一个句子来表达一个想法,
为毛要使用十多行代码? 那也忒自虐了!</p>
<p>所以, 春哥不喜欢 <span class="caps">JAVA</span>, 因为要输入的代码太多了,
Lua 也不是个好形式, 以及其它现有的所有命令式通用开发语言</p>
<p><img alt="p46" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide46_to-convey-the-idea-to-the-machine.png" /></p>
<p>所以有了第一个 <span class="caps">DSL</span>: <code>LZSQL</code></p>
<ul>
<li>基于<span class="caps">SQL</span> 的形式, 快速传达想法给系统</li>
<li>为什么选择 <span class="caps">SQL</span> ? <ul>
<li>因为数据分析产品本质上是基于关系型数据模型的</li>
<li>无论是否使用 <span class="caps">SQL</span> 数据库</li>
</ul>
</li>
<li>我们可以在 <span class="caps">SQL</span> 中定义变量和用户变量, 作为第一公民</li>
<li><span class="caps">SQL</span> 可以在一些 MySQL 后端运行</li>
<li>也可以在 <span class="caps">NGINX</span> 中运行<ul>
<li>因为实现了包含 <span class="caps">SQL</span> 引擎的内存数据库</li>
<li>只有100行左右的 Lua 代码</li>
<li>运行良好</li>
</ul>
</li>
<li>复杂性来源是因为数据不得不来自很多不同的 MySQL 数据库</li>
<li>然后在内存中重新关联, 并组合成最终结果发送到客户端</li>
<li>这其中涉及很多棘手的问题:<ul>
<li>必须能分解 <span class="caps">SQL</span> 到不同节点上运行</li>
<li>同时还能自动优化 <span class="caps">SQL</span> 查询 <ul>
<li>~ MySQL 自己的优化器通常无法完成海量优化</li>
<li>特别是在 <span class="caps">OLAP</span> 场景中</li>
<li>(在线分析过程)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img alt="p47" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide47_writing-the-business-logic-in-LZSQL-files.png" /></p>
<p>最终, 实际上我们用 <span class="caps">LZSQL</span> 来记述业务逻辑,
用编译器生成 Lua 代码,
在线发布 Lua 代码并运行, 而线上不再需要编译器.</p>
<p>这就是 <code>编译</code> 的美妙所在.</p>
<p><img alt="p48" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide48_to-compile-the-LZSQL-files.png" /></p>
<p>当前的, 提供 <span class="caps">CLI</span> 工具,
完成 <span class="caps">LZSQL</span> 脚本的编译, 链接到最终 Lua 应用程序.</p>
<p><img alt="p49" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide49_The-result.png" /></p>
<p>其结果非常赞:</p>
<ul>
<li>因为编译器可以进行很多优化</li>
<li>人通常不能, 甚至于不能正确运行</li>
</ul>
<p>旧业务是 <span class="caps">PHP</span> 编写的,新接口由春哥编译器生成 Lua 代码,</p>
<ul>
<li>请求延迟下降超过 90%,</li>
<li>甚至于这包含了 MySQL 的延迟,</li>
<li>上图是一次完整的 接口 <span class="caps">HTTP</span> 延迟对比</li>
</ul>
<p>值得注意的是, 这时使用的还是标准的 Lua 解释器</p>
<p><img alt="p50" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide50_still-using-the-interpreter-only.png" /></p>
<p>进一步的, 仅仅切换为 LuaJIT , 速度就获得进一步加强</p>
<p><img alt="p51" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide51_4000-lines-of-Perl.png" /></p>
<p>而实际上, <span class="caps">LZSQL</span> 编译器,仅仅是 4000行 Perl 代码, 但是,包含了非常复杂的优化和类型检查以及一应上下文相关的分析过程.</p>
<p><img alt="p52" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide52_several-code-emitters.png" /></p>
<p>而且, 编译器包含了:</p>
<ul>
<li>一个解析自己的解析器</li>
<li>一个 <span class="caps">AST</span>(抽象语法树)</li>
<li>一堆优化器</li>
<li>一个代码映射器<ul>
<li>其实是多种映射器</li>
<li>因为 <span class="caps">LZSQL</span> 支持多种语言后端</li>
</ul>
</li>
</ul>
<p><img alt="p53" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide53_why-not-C-code.png" /></p>
<p>是的, 当时可以生成 Lua 代码,
当然, 也可以生成 C 代码.</p>
<p><img alt="p54" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide54_generate-an-NGINX-model.png" /></p>
<p>是的, 当时后端是一个实时数据库, 提供了非常具体和复杂的线程协议,以至难以人工完成客户端.</p>
<p>但是, 数据库发布有一个完备的wiki 文档:</p>
<ul>
<li>那么为毛不让电脑可以理解文档</li>
<li>自动生成一个 <span class="caps">NGINX</span> C 模块来调用呢?</li>
</ul>
<p>于是, 春哥实现了这个想法</p>
<p><img alt="p55" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide55_Ticpy.png" /></p>
<p><img alt="p56" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide56_implementation-example.png" /></p>
<p>是的, 嘦很小的 <span class="caps">DSL</span> 抽象就可以解析 wiki 文档.</p>
<p><img alt="p57" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide57_a-very-quick-Perl-script.png" /></p>
<p>于是, 再再再次用 Perl 快速完成了一个编译器来从文档生成 <span class="caps">NGINX</span> C 模块,
可以自由的通过 <span class="caps">NGINX</span> 来和数据库交互,</p>
<p>这算 <span class="caps">NGINC</span> 的上游模块.</p>
<p><img alt="p58" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide58_just-300-lines-of-code.png" /></p>
<p>是的, 文档只有300行, 但是生成的 C 模块有12000行代码.</p>
<p><img alt="p59" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide59_Writing-Programs-to-Write-Programs-to-Write-Programs.png" /></p>
<p>这一案例说明:</p>
<ul>
<li>编程就是和机器沟通</li>
<li>如果文档足够完备</li>
<li>那么完全可以直接转换给机器</li>
<li>从而避免了人工编程的各种糟心事儿</li>
<li>这一切指向了一个觉悟:</li>
</ul>
<p>:</p>
<div class="highlight"><pre><span class="err">宁愿写程序上编程来生成代码</span>
</pre></div>
<p>(<code>是也乎:</code> 也嫑直接写业务代码)</p>
<p><img alt="p60" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide60_Test-Scaffold.png" /></p>
<p>同时我们的测试脚手架也是基于 <span class="caps">DSL</span> 的:</p>
<ul>
<li><code>Test::Nginx::Socket</code> 被所有 OpenResty 工程引用</li>
<li>以规范的形式来描述测试用例</li>
</ul>
<p>即使你不会 Perl 也没有关系:</p>
<ul>
<li>嘦按照规范提供描述</li>
<li>服务就能理解并进行对应测试</li>
</ul>
<h3 id="dsl"><span class="caps">DSL</span> 的爆发<a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#dsl" title="Permanent link">¶</a></h3>
<p><img alt="p61" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide61_How-About-Tests.png" /></p>
<p>幻灯参考: http://search.cpan.org/perldoc?Cheater</p>
<p>接下来的一件大事:</p>
<ul>
<li>对于新产品</li>
<li>数据库中还没有真实的业务数据时</li>
<li>如何进行测试?</li>
<li>我们需要数据来测试 <span class="caps">SQL</span> 查询/网页/服务/…</li>
</ul>
<p>所以, 春哥再再再再次用 Perl 实现了一个类似 <span class="caps">SQL</span> 语言的建数据表用的 <span class="caps">DSL</span></p>
<p><img alt="p62" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide62_Cheater.png" /></p>
<p>就是 Cheater 工具:</p>
<ul>
<li>用正则表达式来指定允许渲染的字段</li>
<li>并能指定依赖的外链</li>
<li>那么这工具就能生成满足所有约束和要求的随机数据</li>
</ul>
<p><img alt="p63" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide63_The-OpenResty-Model-Language.png" /></p>
<p>回到 OpenResty 场景中, 从多年前的实验中可以学到:</p>
<ul>
<li>可以通过设计/实现模式语言来简化开发</li>
<li>可以在 OpenResty 中使用 <span class="caps">SQL</span> </li>
<li>编译器知道在哪儿运行:<ul>
<li>本地或是远程</li>
<li>又或是混合</li>
</ul>
</li>
<li>在不同数据库中运行 <span class="caps">SQL</span> ,甚至于不一定是关系型数据库</li>
</ul>
<p><img alt="p64" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide64_The-OpenResty-View-Language.png" /></p>
<p>另外, 也发布有 OpenResty View 语言:</p>
<ul>
<li>基于 <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller"><span class="caps">MVC</span></a> 模型</li>
<li>在 View 层:<ul>
<li>Perl 有 <span class="caps">TT2</span></li>
<li>Python 有 Jinja2</li>
</ul>
</li>
<li>现在有了自己的 <span class="caps">DSL</span> 就可以生成客户端 <span class="caps">JS</span> 或是服务端 Lua 代码</li>
<li>这是 <span class="caps">DSL</span> 的优势</li>
</ul>
<p><img alt="p65" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide65_Jemplate-Lemplate.png" /></p>
<ul>
<li>Jemplate 将 Perl 的 <span class="caps">TT2</span> 模板转换为 <span class="caps">JS</span> 代码</li>
<li>Lemplate 则编译成 OpenResty Lua 代码</li>
</ul>
<p><img alt="p66" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide66_The-OpenResty-Controller-Language.png" /></p>
<p>这又是一件大事儿</p>
<p><img alt="p67" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide67_it%E2%80%99s-a-Lua-based-language.png" /></p>
<p>看起来是这样的:</p>
<ul>
<li>基于规则的语言<ul>
<li>你只需要描述一系列规则</li>
<li>箭头左侧是谓词, 类似条件</li>
<li>箭头右侧是行为, 比如重定向/返回错误码…</li>
</ul>
</li>
<li>那些谓词其实是无效的 (不会导致执行具体的行动)</li>
<li>编译器进一步优化的话, 就能将机关的谓词合并起来</li>
<li>多数 <span class="caps">CDN</span> 业务编辑都可以如此表述&lt;—这就是 <span class="caps">CDN</span> 市场的本质</li>
</ul>
<p>不同的商业模式包含共同的内在特性:</p>
<ul>
<li>这是可能的也是可以的</li>
<li>比如数据分析业务共同的模式是关系模式</li>
<li><span class="caps">SQL</span> 语言洽好是这种模式的表述形式</li>
</ul>
<p>对于 <span class="caps">CDN</span> 或是 <span class="caps">WAF</span> 型的业务:</p>
<ul>
<li>应该就是规则集的模型</li>
<li>理论上是个 <code>前向链专家系统模型</code></li>
</ul>
<p>春哥是 <span class="caps">AI</span> 的资深粉丝</p>
<ul>
<li>高中时就研究过各种流派的 <span class="caps">AI</span> 实现</li>
<li>当前机器学习是热点</li>
<li>而专家系统是 <span class="caps">AI</span> 的分支, 并没有过时</li>
<li>比如说:<ul>
<li>基于 Prolog 的语法解析, 在自然语言研究领域很流行</li>
<li>而语义解析, 则多用 <span class="caps">CLISP</span></li>
</ul>
</li>
<li>70年代 <span class="caps">NASA</span> 就折腾过类似的</li>
</ul>
<p><img alt="p68" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide68_remove-all-the-C-comments.png" /></p>
<p>OpenResty 也支持组合多个 正则表达式 来执行复杂的过滤:</p>
<ul>
<li>这样,所有替换在 <span class="caps">NGNIX</span> 输出过滤器中<ul>
<li>是缓冲实时完成的</li>
<li>所以, 定长缓冲区, 无限数据流处理</li>
</ul>
</li>
<li>非常 <span class="caps">COOL</span> , 不是嘛?</li>
</ul>
<p>上图是批量从 C++ 中删除注释的案例</p>
<ul>
<li>你可以稍微修订就能支持 <span class="caps">CSS</span>/<span class="caps">JS</span> 的注释删除</li>
<li>当然的,这是基于 sregex 的</li>
</ul>
<p><img alt="p69" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide69_-WAF-Hot.png" /></p>
<p><span class="caps">WAF</span> 是热点, 公司已在为 <span class="caps">NGINX</span> 推出 ModSecurity 端口,</p>
<p>春哥看来 <span class="caps">WAF</span> 本身就可以基于前述控制语言来完成.</p>
<p><img alt="p70" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide70_ModSecurity-a-Horrible-DSL.png" /></p>
<p>ModSecurity 本身作为 <span class="caps">DSL</span> 很可怕</p>
<p><img alt="p71" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide72_-Example-of-a-Poor-Rule.png" /></p>
<p>这是 ModSecurity 一个线路的描述</p>
<p>已经复杂到天际了, 而厂商们还发明了各种更加复杂 <span class="caps">WAF</span> 语法,
只是为了表述类似 <code>if-else</code> 的逻辑</p>
<p>那么为什么不创建我们这样简洁的 <span class="caps">DSL</span> ?</p>
<p><img alt="p72" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide71_it%E2%80%99s-a-Lua-based-language-2.png" /></p>
<p>这样的语法就干净很多:</p>
<ul>
<li>也支持短路:如果第一条匹配了,就跳过后续的</li>
<li>本质上只是个 <code>if-else</code> 不必要进行深度嵌套</li>
<li>如果查阅其它 <span class="caps">CDN</span> 厂商的 <span class="caps">VSL</span> 代码<ul>
<li>其实就是一堆堆的 <code>if-else</code></li>
<li>是的, 很疯狂</li>
</ul>
</li>
</ul>
<h3 id="or_2"><span class="caps">OR</span> 的目标<a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#or_2" title="Permanent link">¶</a></h3>
<p><img alt="p73" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide73_Model-View-Controller.png" /></p>
<ul>
<li>模式 ~ 不同种类的商业系统都有内在相似的模型,从而抽象为一个 <span class="caps">DSL</span></li>
<li>视图 ~ 已经完成很多种模板语言,都是 <span class="caps">DSL</span></li>
<li>控制 ~ 也已经展示了, 通过规则的描述可以简洁的完成 <span class="caps">WAF</span> 业务的定义</li>
</ul>
<p><img alt="p74" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide74_SportLang.png" /></p>
<p>运动类游戏当然也可以拥有自己的语言, 来描述业务系统.</p>
<div class="highlight"><pre><span class="err">还能更</span> <span class="n">COOL</span> <span class="err">嘛</span><span class="o">?</span>
</pre></div>
<p>我们作为软件行业的专业人士,
讲真, 强迫其它行业用户(如物理/数学/建筑/哲学…)来使用计算机语言, 这本身算是种耻辱吧.</p>
<p>理想情景中, 我们应该支持用户:</p>
<ul>
<li>使用他们熟悉的领域语言</li>
<li>自然的描述</li>
<li>而机器可以理解并运算</li>
</ul>
<p>而且, 同时:</p>
<ul>
<li><span class="caps">DSL</span> 还包含了大量的自动优化过程</li>
<li>毕竟这不是每个程序猿都知道的技巧</li>
</ul>
<p><img alt="p75" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide75_The-Y-Language.png" /></p>
<p>当前我们内部已经在使用 Y 语言:</p>
<p>这是全新的能调试多种语言的工具, 类似 <span class="caps">GDB</span>, SystemTap, LuaJIT</p>
<p><img alt="p76" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide76_CoffeeScript.png" /></p>
<p>另外也支持 CoffeeScript :</p>
<ul>
<li>毕竟 CoffeeScript 很受欢迎</li>
<li>这种 <span class="caps">DSL</span> 可以生成 <span class="caps">JS</span></li>
<li>现在我们可以从 CoffeeScript 生成 OpenResty Lua 代码</li>
</ul>
<p><img alt="p77" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide77_A-Meta-DSL.png" /></p>
<p>我们也有元<span class="caps">DSL</span>:</p>
<ul>
<li>用来生成其它所有 <span class="caps">DSL</span> 的 <span class="caps">DSL</span></li>
<li>包含 元<span class="caps">DSL</span> 本身</li>
</ul>
<p>我们还有创建编译器的 <span class="caps">DSL</span>, 能生成:</p>
<ul>
<li><span class="caps">DSL</span> 编译器</li>
<li><span class="caps">DSL</span> 优化器</li>
</ul>
<p>Perl 一直是 春哥 的第一序列武器,
但是,并一定是最好的,
最终可能为构建编译创建专用 <span class="caps">DSL</span></p>
<p><img alt="p78" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide78_Clean-Separation.png" /></p>
<p>我们可以在业务描述和业务实现间进行清晰的隔离.</p>
<p>这意味着我们可以一夜之间, 完成业务系统实现技术桟的切换,而不用触动具体的业务代码.</p>
<p>比如说:</p>
<ul>
<li>我们可以将当前运行在 OpenResty 上的业务系统</li>
<li>一键迁移到 C 甚至于汇编代码上</li>
<li>而不会变动业务逻辑</li>
<li>甚至于将来迁移到新技术桟上, 也不用改变业务代码<ul>
<li>只需要编写一个新的后端优化器</li>
<li>并添加到现有的 <span class="caps">DSL</span> 编译器中就好</li>
</ul>
</li>
</ul>
<p><img alt="p79" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide79_Compiling-Style-Web-Frameworks.png" /></p>
<p>此外, 我们也将获得全新的 web 应用框架:</p>
<ul>
<li>编译型的</li>
<li>不再依赖一层层的嵌套, 从而令开发运行都越来越慢</li>
</ul>
<p>我们必须同时实现美丽和效率:</p>
<blockquote>
<p>这是未来商业产品级工程的必须特性</p>
</blockquote>
<p><img alt="p80" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide80_The-Best-Language.png" /></p>
<p>最好的语言就是 <code>商业语言</code> 正如春哥意识到的</p>
<p>基于商业语言开发,还有一个好处就是:</p>
<ul>
<li>一但完成了一个 <span class="caps">DSL</span> </li>
<li>将一些业务逻辑放入后</li>
<li>如果有幸拿到客户原始需求文档</li>
<li>两厢对比,发现接近</li>
<li>就意味着作对了 ;-)</li>
</ul>
<p>其实, 还有最好的方式来描述具体的领域问题:</p>
<p><img alt="p81" src="https://cdn-1.wp.nginx.com/wp-content/uploads/2017/08/Yichun_Zhang-conf2016-slide81_The-Machine-Truly-Understands-Business-Logic.png" /></p>
<p>是的, 只有机器真正理解你的业务逻辑, 那么:</p>
<ul>
<li>可以获得比以往更多的嗯哼</li>
<li>比如自动生成测试用例</li>
<li>完成上下文分析</li>
<li>或者干脆为你即时生成真正可运行的实例</li>
</ul>
<p>(<code>是也乎:</code></p>
<p>这, 才是 OpenResty 真正的目标:</p>
<blockquote>
<p>逼所有程序猿变成产品经理</p>
</blockquote>
<p>)</p>
<h2 id="tlog">TLog<a class="headerlink" href="http://blog.zoomquiet.io/feeds/all.atom.xml#tlog" title="Permanent link">¶</a></h2>
<ul>
<li>.5h 决定嗯哼</li>
<li>2.h 完成上篇</li>
<li>2.5h 完成下篇</li>
</ul></div>







<p class="date">
<a href="http://blog.zoomquiet.io/dsl-atop-openresty.html">by Zoom.Quiet at August 26, 2017 04:00 PM</a>
</p>
</div>
</div>



</div>
<div class="channelgroup">







<h3><a href="http://liguanghe.github.io/" title="Li Guanghe's blog">li guang he</a></h3>


<div class="entrygroup" id="http://liguanghe.github.io/2017/08/26/TimeReport5Month/">
<h4><a href="http://liguanghe.github.io/2017/08/26/TimeReport5Month/">五个月时间账单报告</a></h4>
<div class="entry">
<div class="content">
<h2 id="进步计划"><a href="https://liguanghe.github.io/rss2.xml#进步计划" class="headerlink" title="进步计划"></a>进步计划</h2><ul>
<li>继续坚持之前的目标</li>
<li>开始新项目, 列入 data, career</li>
<li>如果，想看</li></ul></div>







<p class="date">
<a href="http://liguanghe.github.io/2017/08/26/TimeReport5Month/">August 26, 2017 11:35 AM</a>
</p>
</div>
</div>




<div class="entrygroup" id="http://liguanghe.github.io/2017/08/26/DunedinJaffaRace/">
<h4><a href="http://liguanghe.github.io/2017/08/26/DunedinJaffaRace/">Special Day of Dunedin 但尼丁特色一天</a></h4>
<div class="entry">
<div class="content">
<p><a href="https://www.lizhi.fm/2040956/2620595165221732870" target="_blank" rel="external">click here to hear what I was speaking(点此链接听英语语</a></p></div>







<p class="date">
<a href="http://liguanghe.github.io/2017/08/26/DunedinJaffaRace/">August 26, 2017 06:35 AM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>August 20, 2017</h2>

<div class="channelgroup">







<h3><a href="http://blog.junyu.io/" title="浚宇的博客">junyu</a></h3>


<div class="entrygroup" id="http://blog.junyu.io/posts/0016-cover-page-config.html">
<h4><a href="http://blog.junyu.io/posts/0016-cover-page-config.html">给博客穿件外套</a></h4>
<div class="entry">
<div class="content">
<blockquote class="blockquote-center">你的博客，你的使用手册</blockquote>

<a id="more"></a>
<p>这是我一直以来想做的一件事情，在博客的外面加上个人主页，我们散落在互联网上的痕迹越来越多，也越来越凌乱。甚至对作者本身搞清楚自己到底有多少网上的“作品”都是很复杂的一件事情。这时候增加一个个人主页显得尤为重要。</p>
<p>有趣的事情是在Google学术信息时，现代重要的学术大拿几乎人人都有个人主页，不一定会写博客，但是一定会把自己的作品、联系方式、论文、研究方向等统统放出来，供大家使用。而<a href="http://zoomquiet.io/" target="_blank" rel="external">Zoom.Quite</a>的主页极富一个有趣的极客灵魂感。内容之多也是印象深刻。</p>
<p>我之前做过几次尝试，但是效果都不是很理想，也没有找到特别好的办法，今天再次尝试，终于一鼓作气先完成了一个可用的及格版本，写一写，留个纪念。</p>
<h2 id="Github-Pages"><a href="http://blog.junyu.io/atom.xml#Github-Pages" class="headerlink" title="Github Pages"></a>Github Pages</h2><p>Github Pages 是Github 的一个项目，通过在Github托管代码的方式把静态页面组装成可以展示的页面。<a href="https://github.com/showcases/github-pages-examples" target="_blank" rel="external">这里</a>有大量的示例。<br /><a href="https://pages.github.com/" target="_blank" rel="external">主页</a>的视频一目了然，不再赘述。<br />我的主页就是通过Github Pages生成的，使用的是默认的模版，如果不做过多的定制化，仅仅是在主页修改文字的话，内容非常非常的简单。参考我的<a href="https://github.com/Wangjunyu/Leon.junyu" target="_blank" rel="external">仓库</a>。对于这个主题，自己现在还是很满意的。</p>
<h2 id="域名设置"><a href="http://blog.junyu.io/atom.xml#域名设置" class="headerlink" title="域名设置"></a>域名设置</h2><p>以往二级域名的设置已经驾轻就熟。</p>
<blockquote>
<p>以blog.junyu.io的设置为例，在域名服务解析的服务页面修改模式为CNAME，把指向的地址修改为：wangjunyu.gitub.io. ，保存即可。如果还无法连接，回到Github查看设置，一般的做法是增加CNAME文件，修改默认分支为gh-pages。</p>
</blockquote>
<p>这一次设置的是一级域名以及开头为www 的跳转，按照之前的方式设置始终无法生效。之后从官方文档的<a href="https://help.github.com/articles/using-a-custom-domain-with-github-pages/" target="_blank" rel="external">Using a custom domain with GitHub Pages
</a>开始一页一页的找，终于在<a href="https://help.github.com/articles/about-supported-custom-domains/#apex-domains" target="_blank" rel="external">About supported custom domains
</a>找到了端倪：</p>
<blockquote>
<p>An apex domain is usually configured with an A, ALIAS, or ANAME record through your DNS provider.</p>
</blockquote>
<p>对于一级域名的设置，一般是在填写二级域名的地方写上<code>@</code>，选择A 或者ALIAS 模式，跳转的地址需要使用ip，在上面提到的文档中有提到。修改之后，还可以用文档中提到的’dig’ 命令进行测试。貌似一级域名的调整需要一些时间，不过一般来说十几分钟也就够了。</p>
<p>最后，展示一下我的<a href="http://junyu.io" target="_blank" rel="external">主页</a></p>
<h2 id="Reference"><a href="http://blog.junyu.io/atom.xml#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://help.github.com/articles/setting-up-an-apex-domain/" target="_blank" rel="external">Setting up an apex domain</a></li>
<li><a href="https://help.github.com/articles/setting-up-an-apex-domain-and-www-subdomain/" target="_blank" rel="external">Setting up an apex domain and www subdomain</a></li>
<li><a href="https://help.github.com/articles/about-supported-custom-domains/#www-subdomains" target="_blank" rel="external">About supported custom domains
</a></li>
</ul>
<blockquote class="blockquote-center"><a href="http://blog.junyu.pro" target="_blank" rel="external">完</a></blockquote>


<h2 id="ChangeLog"><a href="http://blog.junyu.io/atom.xml#ChangeLog" class="headerlink" title="ChangeLog"></a>ChangeLog</h2><p>170820 新建</p></div>







<p class="date">
<a href="http://blog.junyu.io/posts/0016-cover-page-config.html">August 20, 2017 12:03 PM</a>
</p>
</div>
</div>


</div>

</div>
<div class="daygroup">
<h2>August 18, 2017</h2>

<div class="channelgroup">







<h3><a href="http://du.zoomquiet.io/" title="自怼圈">Debug Uself grp.</a></h3>


<div class="entrygroup" id="http://du.zoomquiet.io/2017-08/aoi-crontab">
<h4><a href="http://du.zoomquiet.io/2017-08/aoi-crontab/">Aoi-crontab</a></h4>
<div class="entry">
<div class="content">
<h1 id="crontab-是位好伙伴">crontab 是位好伙伴</h1>

<p>planet 很简单粗暴,只是:</p>

<ul>
  <li>如何免费的发布成网站?</li>
  <li>又如何自动的刷新?</li>
</ul>

<!--more-->

<h2 id="github-pages">github-pages</h2>
<p>~ <a href="https://help.github.com/articles/user-organization-and-project-pages/">User, Organization, and Project Pages - User Documentation</a></p>

<p>第一时间想到 <code class="highlighter-rouge">github-pages</code> :</p>

<ul>
  <li>只是记忆中要一个特殊的孤子分支什么的…</li>
  <li>结果官方文档一看:
    <ul>
      <li>master, gh-pages, or a /docs folder on master</li>
      <li>嗯哼?! 可以用约定的一个 master 目录就可以了?</li>
    </ul>
  </li>
</ul>

<p><img src="http://openmindclub.qiniucdn.com/res/debuguself/github_pages_docs.png" alt="github_pages_docs.png（PNG 图像，494x548 像素）" /></p>

<p>果然…那就简单了</p>

<div class="highlighter-rouge"><pre class="highlight"><code>output_dir = docs
</code></pre>
</div>

<p>将相关配置文件中, 指定的输出目录变成 <code class="highlighter-rouge">docs</code>,
每次 push 到 github 时,就完成了网站的更新.</p>

<h2 id="定期的嗯哼">定期的嗯哼</h2>
<p>~ 在所有 UNIX/Linux 环境中, 当前是 crontab</p>

<p>参考:<a href="https://help.ubuntu.com/community/CronHowto">CronHowto - Community Help Wiki</a></p>

<p>先在用户 crontab 中配置</p>

<div class="highlighter-rouge"><pre class="highlight"><code># m h  dom mon dow   command
*/10 *     * * *   /opt/cron/updates.sh
</code></pre>
</div>

<p>每 10 秒调用一次 <a href="https://github.com/zoom-quiet/scm/blob/master/sh/cron/updates.sh">updates.sh</a> 以便调试</p>

<p>调试好后, 更新配置为</p>

<div class="highlighter-rouge"><pre class="highlight"><code># m h  dom mon dow   command
42 */8     * * *   /opt/cron/updates.sh
</code></pre>
</div>

<p>每8小时的第42分钟,运行一次, 并将日志输出为:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>opt/log/cron on default
$ ls -1
170818-planet.log
170819-planet.log
170820-planet.log
170821-planet.log
</code></pre>
</div>

<p>这种形式…</p>

<h2 id="整体图谱">整体图谱</h2>
<p>~ 所以, 最终通过一台家用服务器, 无值守的完成了一大类静态网站的更新和发布</p>

<div class="highlighter-rouge"><pre class="highlight"><code>                            du.zoomquiet.io/planet/
                                  ^ 
                                  |
                          [[github-pages]]
{rss} {rss} ... {rss}             ^
  \     |         /               |
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        internet                  ^
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        home wifi                 ^ 
            |                     |
            V                     |
        Ubuntu 16.4               | 
       /[ miniPC ]                |
      /     |                     |
  crontab   |                     |
    |       V                     +
    +---&gt;(Planet) --&gt; HTML -&gt; git push
</code></pre>
</div>

<h1 id="todo">TODO</h1>
<p>~ 当然的故事远没有可以结束, 等待继续折腾的有:</p>

<ul>
  <li>固化 wifi 连接的 ip</li>
  <li>在 pyenv 中也能安装使用 baddb</li>
  <li>将更新成果 email 给自己,以便知晓</li>
  <li>将失败的更新 通过短信/微信/Slcak 等等渠道提醒自己</li>
  <li>通过 Slack 或是其它渠道, 可以发布指令给主机进行各种必要的行为</li>
  <li>…</li>
</ul>

<h1 id="用时">用时</h1>

<ul>
  <li>.5h 研究 github-pages 文档</li>
  <li>1.h 实验明确 docs 效果</li>
  <li>1.h 调试 crontab 脚本</li>
  <li>.5h 测试全部自动化行为</li>
  <li>1.h ASCII 图谱和文档化</li>
</ul></div>







<p class="date">
<a href="http://du.zoomquiet.io/2017-08/aoi-crontab/">August 18, 2017 12:00 AM</a>
</p>
</div>
</div>


</div>

</div>


<div class="sidebar">
<img src="images/logo.png" width="136" height="136" alt="">

<h2>Subscriptions</h2>
<ul>
<li>
<a href="http://du.zoomquiet.io/atom.xml" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="http://du.zoomquiet.io/" title="自怼圈">Debug Uself grp.</a>
</li>
<li>
<a href="https://bambooom.github.io/feed.xml" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="http://bambooom.github.io" title="">bambooooooom</a>
</li>
<li>
<a href="http://blog.junyu.io/atom.xml" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="http://blog.junyu.io/" title="浚宇的博客">junyu</a>
</li>
<li>
<a href="https://liguanghe.github.io/rss2.xml" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="http://liguanghe.github.io/" title="Li Guanghe's blog">li guang he</a>
</li>
<li>
<a href="https://mxclover.github.io/atom.xml" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="https://mxclover.github.io/" title="mxclover">mxclover</a>
</li>
<li>
<a href="http://blog.zoomquiet.io/feeds/all.atom.xml" title="subscribe"><img src="images/feed-icon-10x10.png" alt="(feed)"></a> <a href="http://blog.zoomquiet.io/" title="">zoom.quiet</a>
</li>
</ul>

<p>
<strong>Last updated:</strong><br>
August 29, 2017 04:42 PM<br>
<em>All times are UTC.</em><br>
<br>
Powered by:<br>
<a href="http://www.planetplanet.org/"><img src="images/planet.png" width="80" height="15" alt="Planet" border="0"></a>
</p>

<p>
<h2>Planetarium:</h2>
<ul>
<li><a href="http://www.planetapache.org/">Planet Apache</a></li>
<li><a href="http://planet.debian.net/">Planet Debian</a></li>
<li><a href="http://planet.freedesktop.org/">Planet freedesktop.org</a></li>
<li><a href="http://planet.gnome.org/">Planet GNOME</a></li>
<li><a href="http://planetsun.org/">Planet Sun</a></li>
<li><a href="http://fedora.linux.duke.edu/fedorapeople/">Fedora People</a></li>
<li><a href="http://www.planetplanet.org/">more...</a></li>
</ul>
</p>
</div>
</body>

</html>
